/**
 * Project Wonderland
 *
 * Copyright (c) 2004-2008, Sun Microsystems, Inc., All Rights Reserved
 *
 * Redistributions in source code form must reproduce the above
 * copyright and this condition.
 *
 * The contents of this file are subject to the GNU General Public
 * License, Version 2 (the "License"); you may not use this file
 * except in compliance with the License. A copy of the License is
 * available at http://www.opensource.org/licenses/gpl-license.php.
 *
 * Sun designates this particular file as subject to the "Classpath" 
 * exception as provided by Sun in the License file that accompanied 
 * this code.
 */
package imi.scene.shader.dynamic;

import com.jme.scene.state.GLSLShaderObjectsState;
import com.jme.scene.state.RenderState;
import com.jme.scene.state.jogl.JOGLShaderObjectsState;
import imi.scene.polygonmodel.PPolygonMeshInstance;
import imi.scene.shader.AbstractShaderProgram;
import imi.scene.shader.NoSuchPropertyException;
import imi.scene.shader.ShaderProperty;
import imi.scene.shader.ShaderUtils;
import imi.scene.shader.dynamic.GLSLDefaultVariables.Locality;
import imi.serialization.xml.bindings.xmlShaderProgram;
import imi.utils.StringStack;
import java.io.IOException;
import java.io.Serializable;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.media.opengl.GL;
import javax.media.opengl.glu.GLU;
import javolution.util.FastSet;
import org.jdesktop.mtgame.RenderUpdater;
import org.jdesktop.mtgame.WorldManager;

/**
 * This class represents a complete shader program, comprised of a series of 
 * effects. It is used as a wrapper to bundle effects in a specific way to 
 * acheive an overall net visual effect. 
 * ** NOTE ** This class, including its public interface, is still under
 * heavy development and should be considered as volatile.
 * @author Ronald E Dahlgren
 */
public class GLSLShaderProgram implements AbstractShaderProgram, RenderUpdater, Serializable
{
    /** Serialization version number **/
    private static final long serialVersionUID = 1l;

    /** logger ref **/
    private static final Logger logger = Logger.getLogger(GLSLShaderProgram.class.getName());
    /**
     * Convenience reference to the shader newline character
     */
    protected static final String   NL  = GLSLDefaultVariables.ShaderNewline;

    private static final float timeOut = 3.0f; // 3 Seconds.
    /**
     * This string is inserted at the beginning of each source
     * string.
     */
    protected final static String preamble = new String(
            "/****************************************" + NL +
            "* Autogenerated shader code follows"       + NL +
            "*     this is a placeholder header"        + NL +
            "*         resistance is futile"            + NL +
            "****************************************/" + NL
            );
    
    /** The name of this program **/
    private String    m_programName = null;
    /** The description of what this program does **/
    private String    m_programDescription = null;
    
    /**
     * The list of shader effects that comprise this program
     */
    private final ArrayList<GLSLShaderEffect> m_effects = new ArrayList<GLSLShaderEffect>();
    
    // the following two containers are used during the compilation process
    private Map<GLSLShaderVariable, GLSLShaderEffect> m_dependencyMap = null;
    private FastSet<GLSLShaderVariable> m_initializationBuffer = null;
    // this container caches results of part of the compilation process
    protected final FastSet<GLSLVertexAttribute> m_vertAttributes = new FastSet<GLSLVertexAttribute>();
    
    /**
     * Determines whether or not the program will attempt to resolve unsatisfied
     * dependencies using default initialization strings (defined in 
     * GLSLDefaultVariables
     */
    private boolean m_bUseDefaultInitializers = false;
    
    /**
     * The compiled and complete vertex program source
     */
    private StringBuilder m_VertexProgramSource = new StringBuilder();
    /**
     * The compile and complete fragment program source
     */
    private StringBuilder m_FragmentProgramSource = new StringBuilder();
    
    /** This boolean is used for blocking while the render thread creates shader objects**/
    protected boolean       m_bShaderLoaded = false;
    /**
     * Used to create render states as well as adding instances onto the render
     * thread.
     */
    protected transient WorldManager  m_WM = null;
    /** Render state that will be applied to meshes **/
    private transient GLSLShaderObjectsState shaderState = null;
    
    /**
     * Mapping of property names to their instances
     */
    protected Map<String,ShaderProperty> m_propertyMap  = new HashMap<String,ShaderProperty>();

    public GLSLShaderProgram(WorldManager wm)
    {
        this(wm, true);
    }
    /**
     * Create a new instance
     * @param wm The world manager
     * @param useDefaultInitializers Should default initializers be used
     */
    public GLSLShaderProgram(WorldManager wm, boolean useDefaultInitializers)
    {
        setWorldManager(wm);
        shaderState = (GLSLShaderObjectsState) m_WM.getRenderManager().createRendererState(RenderState.StateType.GLSLShaderObjects);
        m_bUseDefaultInitializers = useDefaultInitializers;
    }

    /**
     * Copy constructor. All effects are copied over as well as all the properties
     * and the source strings.
     * @param other The program to copy
     */
    protected GLSLShaderProgram(GLSLShaderProgram other)
    {
        m_effects.addAll(other.getEffects());
        m_bUseDefaultInitializers = other.isUsingDefaultInitializers();
        m_bShaderLoaded = other.m_bShaderLoaded;
        m_VertexProgramSource = new StringBuilder(other.m_VertexProgramSource);
        m_FragmentProgramSource = new StringBuilder(other.m_FragmentProgramSource);
        setWorldManager(other.m_WM);

        shaderState = (GLSLShaderObjectsState) m_WM.getRenderManager().createRendererState(RenderState.StateType.GLSLShaderObjects);

        for (ShaderProperty prop : other.getProperties())
            m_propertyMap.put(prop.name, new ShaderProperty(prop));

        for (GLSLVertexAttribute attr : other.m_vertAttributes)
            m_vertAttributes.add(attr);

        m_programName = new String(other.m_programName);
        m_programDescription = new String(other.m_programDescription);

        // Update our shader state to reflect this.
        loadAndCompileShader();

    }
    
    /**
     * This method parses the collection of effects and assembles
     * them into vertex and fragment shader source code. 
     * @throws dynshadegen.GLSLCompileException Exception thrown if something
     * goes awry, such as an unsatisfied dependency
     */
    public void compile() throws GLSLCompileException
    {
        long startTime = System.nanoTime();
        // prepare buffers
        m_initializationBuffer  = new FastSet<GLSLShaderVariable>();
        m_dependencyMap         = new HashMap<GLSLShaderVariable, GLSLShaderEffect>();
        m_vertAttributes.clear();
        
        m_VertexProgramSource = createVertexSource();
        m_FragmentProgramSource = createFragmentSource();
        
        fixVariantDependencies();
        
        formatSourceStrings();
        
        synchronizePropertyObjects();
        // Update our shader objects state to reflect this
        loadAndCompileShader();
        
        // free buffers
        m_initializationBuffer = null;
        m_dependencyMap = null;

        long endTime = System.nanoTime();
        float duration = (endTime - startTime) / 1000000000.0f;
        logger.info("Compiled shader " + getProgramName() + ". Took " + duration + " seconds.");

    }
    
    /**
     * This method parses the collection of effects and intelligently combines
     * them to form the fragment source code.
     * @return A StringBuilder instance with the fragment source
     * @throws dynshadegen.GLSLCompileException Thrown if something goes awry, 
     * such as an unsatisfied dependency.
     */
    private StringBuilder createFragmentSource() throws GLSLCompileException
    {
        StringBuilder result = new StringBuilder(preamble);
        // first, generate a set of all the uniforms,
        // varying and global variable declarations
        HashSet<String> uniforms   = new HashSet<String>();
        HashSet<String> variants   = new HashSet<String>();
        HashSet<String> globals    = new HashSet<String>();
        
        for (GLSLShaderEffect effect : m_effects)
        {
            
            if (effect.getFragmentUniforms() != null)
            {
                for (GLSLShaderUniform uniform : effect.getFragmentUniforms())
                    uniforms.add(uniform.declare());
            }
            
            if (effect.getVariants() != null)
            {
                for (GLSLShaderVarying variant : effect.getVariants())
                    variants.add(variant.declare());
            }
            
            if (effect.getFragmentGlobals() != null)
            {
                for (GLSLShaderVariable var : effect.getFragmentGlobals())
                    globals.add(var.declare());
            }
        }
        
        // now add these declarations to the source string
        Iterator<String> iter = null;
        if (variants.size() > 0)
            result.append("///////////// VARYING /////////////" + NL);
        for (iter = variants.iterator(); iter.hasNext(); /* update in loop */)
            result.append(iter.next());
        if (uniforms.size() > 0)
            result.append(NL + "////////////  UNIFORMS ////////////" + NL);
        for (iter = uniforms.iterator(); iter.hasNext(); /* update in loop */)
            result.append(iter.next());
        if (globals.size() > 0)
            result.append(NL + "///////////// GLOBALS /////////////" + NL);
        for (iter = globals.iterator(); iter.hasNext(); /* update in loop */)
            result.append(iter.next());
        
        result.append(NL + "//////////// PROTOTYPES ///////////" + NL);
            for (GLSLShaderEffect effect : m_effects)
                if (effect.getFragmentLogic() != null)
                    result.append("void " + effect.getEffectName() + "();" + NL);
            
        result.append(NL + "/////////// MAIN LOGIC ////////////" + NL);
        result.append("void main(void)" + NL);
        result.append("{" + NL);
        // Now assemble the list of method calls if applicable
        for (GLSLShaderEffect effect : m_effects)
            if (effect.getFragmentLogic() != null)
                result.append(effect.m_effectName + "();" + NL);
        // Now tack on the fragment finalization code
        result.append(NL + "// Now commit the changes" + NL);
        result.append("gl_FragColor = " + GLSLDefaultVariables.FinalFragmentColor.getName() + ";" + NL);
        // end main
        result.append("}" + NL);
        
        // prepare buffers
        m_initializationBuffer.clear();
        m_dependencyMap.clear();
        
        // place in method bodies if applicable
        for (GLSLShaderEffect effect : m_effects)
        {
            if (effect.getFragmentLogic() != null)
            {
                result.append(NL +  "/******************************************" + NL);
                result.append(      "* Function: " + effect.getEffectName() + NL);
                result.append(      "*******************************************/" + NL);
                result.append("void " + effect.m_effectName + "()" + NL);
                result.append("{" + NL);
                result.append(effect.getFragmentLogic());
                result.append("}" + NL);
                // track fragment and variant dependencies and fragment calculations
                // this is followed here because the ordering is intended to be
                // relevant
                // initializations
                if (effect.getFragmentInitializations() != null)
                    m_initializationBuffer.addAll(effect.getFragmentInitializations());
                // add relevant dependencies
                if (effect.getFragmentDependencies() != null)
                    for (GLSLShaderVariable var : effect.getFragmentDependencies())
                        if (m_initializationBuffer.contains(var) == false) // not initialized at this point
                            m_dependencyMap.put(var, effect);
            }
        }
        
        fixDependencies(Locality.FRAGMENT, result);
        // release containers
        m_initializationBuffer.clear();
        m_dependencyMap.clear();
        return result;
    
    }
    
    /**
     * This method parses the collection of effects and intelligently combines
     * them to form the vertex source code.
     * @return A StringBuilder instance with the vertex source
     * @throws dynshadegen.GLSLCompileException Thrown if something goes awry, 
     * such as an unsatisfied dependency.
     */
    private StringBuilder createVertexSource() throws GLSLCompileException
    {
        StringBuilder result = new StringBuilder(preamble);
        // first, generate a set of all the attributes, uniforms,
        // varying and global variable declarations
        HashSet<String> attributes = new HashSet<String>();
        HashSet<String> uniforms   = new HashSet<String>();
        HashSet<String> variants   = new HashSet<String>();
        HashSet<String> globals    = new HashSet<String>();
        
        for (GLSLShaderEffect effect : m_effects)
        {
            if (effect.getVertexAttributes() != null)
            {
                for (GLSLVertexAttribute vertAttribute : effect.getVertexAttributes())
                {
                    attributes.add(vertAttribute.declare());
                    m_vertAttributes.add(vertAttribute);
                }
            }
            
            if (effect.getVertexUniforms() != null)
            {
                for (GLSLShaderUniform uniform : effect.getVertexUniforms())
                {
                    // look out for special case
                    if (uniform != GLSLDefaultVariables.Pose)
                        uniforms.add(uniform.declare());
                    else
                        uniforms.add(new String("uniform mat4 pose[55];" + NL));
                }
            }
            
            if (effect.getVariants() != null)
            {
                for (GLSLShaderVarying variant : effect.getVariants())
                    variants.add(variant.declare());
            }
            
            if (effect.getVertexGlobals() != null)
            {
                for (GLSLShaderVariable var : effect.getVertexGlobals())
                    globals.add(var.declare());
            }
        }
        
        // now add these declarations to the source string
        Iterator<String> iter = null;
        if (attributes.size() > 0)
            result.append("//////////// ATTRIBUTES ////////////" + NL);
        for (iter = attributes.iterator(); iter.hasNext(); /* update in loop */)
            result.append(iter.next());
        if (variants.size() > 0)
            result.append(NL + "///////////// VARYING /////////////" + NL);
        for (iter = variants.iterator(); iter.hasNext(); /* update in loop */)
            result.append(iter.next());
        if (uniforms.size() > 0)
            result.append(NL + "////////////  UNIFORMS ////////////" + NL);
        for (iter = uniforms.iterator(); iter.hasNext(); /* update in loop */)
            result.append(iter.next());
        if (globals.size() > 0)
            result.append(NL + "///////////// GLOBALS /////////////" + NL);
        for (iter = globals.iterator(); iter.hasNext(); /* update in loop */)
            result.append(iter.next());
        result.append(NL + "//////////// PROTOTYPES ///////////" + NL);
            for (GLSLShaderEffect effect : m_effects)
                if (effect.getVertexLogic() != null)
                    result.append("void " + effect.getEffectName() + "();" + NL);
        
        result.append(NL + "/////////// MAIN LOGIC ////////////" + NL);
        result.append("void main(void)" + NL);
        result.append("{" + NL);
        
        // prepare buffers
        m_initializationBuffer.clear();
        m_dependencyMap.clear();
        // Now assemble the list of method calls if relevant
        for (GLSLShaderEffect effect : m_effects)
            if (effect.getVertexLogic() != null)
                result.append(effect.m_effectName + "();" + NL);
        
        // Now tack on the fragment finalization code
        result.append(NL + "// Now commit the changes" + NL);
        result.append("gl_Position = gl_ModelViewProjectionMatrix * " + GLSLDefaultVariables.Position.getName() + ";" + NL);
        // end main
        result.append("}" + NL);
        // clear out data structures
        globals.clear();
        // place in method bodies if applicable
        for (GLSLShaderEffect effect : m_effects)
        {
            if (effect.getVertexLogic() != null)
            {
                result.append(NL +  "/******************************************" + NL);
                result.append(      "* Function: " + effect.getEffectName() + NL);
                result.append(      "*******************************************/" + NL);
                result.append( "void " + effect.m_effectName + "()" + NL);
                result.append("{" + NL);
                result.append(effect.getVertexLogic());
                result.append("}" + NL);
                // track fragment and variant dependencies and fragment calculations
                // this is followed here because the ordering is intended to be
                // relevant
                // initializations
                if (effect.getVertexInitializations() != null)
                    m_initializationBuffer.addAll(effect.getVertexInitializations());
                // add relevant dependencies
                if (effect.getVertexDependencies() != null)
                    for (GLSLShaderVariable var : effect.getVertexDependencies())
                        if (m_initializationBuffer.contains(var) == false) // not initialized at this point
                            m_dependencyMap.put(var, effect);
            }
        }
        
        fixDependencies(Locality.VERTEX, result);
        
        m_initializationBuffer.clear();
        m_dependencyMap.clear();
        return result;
    }

    /**
     * This method is used to find unsatisfied dependencies within the provided
     * source code. If the program is set to use default initializers, any
     * unintialized dependencies will be fixed using default initialization
     * strings.
     * @param where Indicate the locality of this source code.
     * @param sourceCode 
     * @throws dynshadegen.GLSLCompileException Thrown if no initialization code
     * can be found for a particular dependency
     */
    private void fixDependencies(Locality where, StringBuilder sourceCode) throws GLSLCompileException
    {
        // are there any dependencies unresolved?
        if (m_dependencyMap.size() > 0)
        {
            // are we set to automatically use default initializers?
            Iterator<GLSLShaderVariable> iter = m_dependencyMap.keySet().iterator();
            while (iter.hasNext()) 
            {
                GLSLShaderVariable shadervar = iter.next();
                if (shadervar instanceof GLSLShaderVarying)
                    continue; // processed elsewhere
                if (m_bUseDefaultInitializers == false)
                {
                    throw new GLSLUnsatisfiedDependencyException(
                        "Dependency on " + shadervar.getName() +
                        " in " + where.toString() + " required by " + m_dependencyMap.get(shadervar).getEffectName() + " and not met");
                }
                String initVar = shadervar.getName();
                String initCode = GLSLDefaultVariables.DefaultInitializers.get(initVar);
                if (initCode == null)
                    throw new GLSLUnsatisfiedDependencyException("No default initializer for " + initVar + "!");
                else
                {
                    // post it in the initialization section of the shader
                    int index = sourceCode.indexOf("main(void)" + NL + "{" + NL);
                    if (index >= 0 && !(shadervar instanceof GLSLShaderVarying)) // variants are fixed elsewhere
                    {
                        // adjust for offset
                        index += NL.length() * 2 + 11; // 7 = strlen("main(void){");
                        sourceCode.insert(index, initCode);
                    }
                }
            }
        }
    }

    /**
     * This method is used to determine what variants are listed as
     * dependencies but uninitialized, and if appropriate the uninitialized
     * will be fixed with the default initialization strings.
     * @throws dynshadegen.GLSLCompileException
     */
    private void fixVariantDependencies() throws GLSLCompileException
    {
        m_initializationBuffer.clear();
        m_dependencyMap.clear();
        // accumulate variant initializations in the vertex code
        for (GLSLShaderEffect effect : m_effects)
        {
            if (effect.getVertexInitializations() != null)
                for (GLSLShaderVariable var : effect.getVertexInitializations())
                    if (var instanceof GLSLShaderVarying)
                        m_initializationBuffer.add(var);
        }
        // compare with variant dependencies in the fragment code
        for (GLSLShaderEffect effect : m_effects)
        {
            if (effect.getFragmentDependencies() != null)
                for (GLSLShaderVariable var : effect.getFragmentDependencies())
                    if (var instanceof GLSLShaderVarying && m_initializationBuffer.contains(var) == false)
                        m_dependencyMap.put(var, effect);
                    
        }
        
        
        if (m_dependencyMap.size() > 0)
        {
            if (m_bUseDefaultInitializers == true)
            {
              Iterator<GLSLShaderVariable> iter = m_dependencyMap.keySet().iterator();
                while (iter.hasNext()) 
                {
                    GLSLShaderVariable shadervar = iter.next();
                    String initVar = shadervar.getName();
                    String initCode = GLSLDefaultVariables.DefaultInitializers.get(initVar);
                    if (initCode == null)
                        throw new GLSLUnsatisfiedDependencyException("No default initializer for " + initVar + "!");
                    else
                    {
                        // post it in the initialization section of the shader
                        int index = m_VertexProgramSource.indexOf("main(void)" + NL + "{" + NL);
                        if (index >= 0) // variants are fixed elsewhere
                        {
                            // adjust for offset
                            index += NL.length() * 2 + 11; // 7 = strlen("main(void){");
                            m_VertexProgramSource.insert(index, initCode);
                        }
                    }
                }
            }
            else
            {
                GLSLShaderVariable shadervar = m_dependencyMap.keySet().iterator().next();
                throw new GLSLUnsatisfiedDependencyException(
                        "Dependency on varying \"" + 
                        shadervar.getName() +
                        "\" required by " + m_dependencyMap.get(shadervar).getEffectName() + " was unsatisfied.");
            }
        }
        
        m_initializationBuffer.clear();
        m_dependencyMap.clear();
    }

    /**
     * This method parses the source strings and formats them by adding on
     * indentation where necessary, and replacing the shader new line string
     * with the appropriate newline character for this platform.
     * @throws dynshadegen.GLSLCompileException
     */
    private void formatSourceStrings() throws GLSLCompileException
    {
        String newline = System.getProperty("line.separator");
        
        StringStack indentation = new StringStack();
        
        String sourceString = null;
        
        sourceString = m_VertexProgramSource.toString();
        for (int i = 0; i < sourceString.length(); ++i)
        {
            if (sourceString.charAt(i) == '{')
                indentation.push("\t");
            else if (sourceString.charAt(i) == '}')
                indentation.pop();
            // try the replacement
            if (sourceString.indexOf(NL) == i)
            {
                // if the next character is a curly brace, pop off a tab
                if (i + NL.length() < sourceString.length() && sourceString.charAt(i+NL.length()) == '}')
                    indentation.pop();
                sourceString = sourceString.replaceFirst(NL, newline + indentation.toString());
                // reset index
                indentation.clear();
                i = 0;
            }
        }
        m_VertexProgramSource = new StringBuilder(sourceString);
        
        indentation.clear();
        
        sourceString = m_FragmentProgramSource.toString();
        for (int i = 0; i < sourceString.length(); ++i)
        {
            if (sourceString.charAt(i) == '{')
                indentation.push("\t");
            else if (sourceString.charAt(i) == '}')
                indentation.pop();
            // try the replacement
            if (sourceString.indexOf(NL) == i)
            {
                // if the next character is a curly brace, pop off a tab
                if (i + NL.length() < sourceString.length() && sourceString.charAt(i+NL.length()) == '}')
                    indentation.pop();
                sourceString = sourceString.replaceFirst(NL, newline + indentation.toString());
                // reset index
                indentation.clear();
                i = 0;
            }
        }
        m_FragmentProgramSource = new StringBuilder(sourceString);
    }
    
    /**
     * Using default initializers allows dependencies on variables with
     * default initialization strings (defined in GLSLDefaultVariables) to
     * be initialized in the case of an unsatisfied dependency.
     * @param bDefaults
     */
    public void setUseDefaultInitializers(boolean bDefaults)
    {
        m_bUseDefaultInitializers = bDefaults;
    }

    /**
     * This method searches the list of effects in the shader and determines
     * whether it already contains the indicated effect
     * @param effect
     * @return True if found, false otherwise
     */
    public boolean containsEffect(GLSLShaderEffect effect)
    {
        for (GLSLShaderEffect myEffect : m_effects)
        {
            if (myEffect.getEffectName().equals(effect.getEffectName()))
                return true;
        }
        return false;
    }
    
    /**
     * Accessor
     * @return True if using default initializers
     */
    public boolean isUsingDefaultInitializers()
    {
        return m_bUseDefaultInitializers;
    }
    
    /**
     * Retrieve the name of this program
     * @return
     */
    public String getProgramName()
    {
        return m_programName;
    }
    
    /**
     * Set the name of this program
     * @param name
     */
    public void setProgramName(String name)
    {
        m_programName = name;
    }
    
    /**
     * Retrieve the description of what this program does.
     * @return
     */
    public String getProgramDescription()
    {
        return m_programDescription;
    }
    
    /**
     * Set the description for this program
     * @param description
     */
    public void setProgramDescription(String description)
    {
        m_programDescription = description;
    }
    
    /**
     * Retrieves the number of effects currently being used in this program
     * @return The number of effects.
     */
    public int getEffectCount()
    {
        return m_effects.size();
    }
    
    /**
     * Retrieve the effect at the specified index. No range checking is performed.
     * @param index The index to retrieve
     * @return The specified effect
     */
    public GLSLShaderEffect getEffect(int index)
    {
        return m_effects.get(index);
    }
    
    /**
     * Retrieve a reference to the backing ArrayList 
     * @return the collection
     */
    public ArrayList<GLSLShaderEffect> getEffects()
    {
        return m_effects;
    }
    
    /**
     * Sets the specified effect. If the index is invalid, nothing will be
     * set and the method will return false.
     * @param index The index to set the effect at.
     * @param effect The effect to place at the specified index
     * @return True on success, false otherwise
     */
    public boolean setEffect(int index, GLSLShaderEffect effect)
    {
        if (index >= m_effects.size())
            return false;
        m_effects.set(index, effect);
        return true;
    }
    
    /**
     * Adds an effect to the end of the collection.
     * @param effect The effect to add.
     * @return The index of the newly added effect
     */
    public int addEffect(GLSLShaderEffect effect)
    {
        m_effects.add(effect);
        return m_effects.size() - 1;
    }

    public boolean removeEffect(String name)
    {
        for (int i = 0; i < m_effects.size(); ++i)
        {
            if (m_effects.get(i).getEffectName().equals(name))
            {
                m_effects.remove(i);
                return true;
            }
        }
        return false;
            
    }
    
    public boolean removeEffect(GLSLShaderEffect effect)
    {
        return removeEffect(effect.getEffectName());
    }
    /**
     * Retrieve the string representation of the vertex source. This represents 
     * the state of the program at the last call to <code>compile</code>.
     * @return The vertex source
     */
    public String getVertexProgramSource()
    {
        return m_VertexProgramSource.toString();
    }
    
    /**
     * Retrieve the string representation of the fragment source. This represents 
     * the state of the program at the last call to <code>compile</code>.
     * @return The fragment source
     */
    public String getFragmentProgramSource()
    {
        return m_FragmentProgramSource.toString();
    }
    
    /**
     * Assign the world manager reference for the program to use when generating
     * the GLSLShaderObjectsState
     * @param wm The world manager
     */
    public void setWorldManager(WorldManager wm)
    {
        if (wm == null)
            throw new IllegalArgumentException("The shader must have a valid worldmanager!");
        m_WM = wm;
    }
    ////////////////////////////////////////////////////////////////////////////
    //          ABSTRACT SHADER INTERFACE IMPLEMENTATION FOLLOWS              //
    ////////////////////////////////////////////////////////////////////////////
    /**
     * This method uses the currently stored source strings to compile a
     * shader object from the underlying graphics API. This method blocks
     * while waiting on the render thread for loading the shader object.
     * @param inst The mesh instance to apply to.
     * @return True on success, false otherwise.
     */
    @Override
    public synchronized boolean applyToMesh(PPolygonMeshInstance meshInst)
    {
        if (m_WM == null) // No world manager!
        {
            logger.severe("Cannot apply a shader without a world manager! " +
                    "Mesh in question was " + meshInst.getName());
            return false;
        }

        // apply uniforms
        ShaderUtils.assignProperties(m_propertyMap.values(), shaderState);
        meshInst.setShaderState(shaderState);
        
        return true;
    }

    /**
     * Implementation of RenderUpdater
     * @param obj
     */
    public void update(Object obj)
    {
        // obj was an alias for our shaderState member variable.
        shaderState.load(getVertexProgramSource().toString(), getFragmentProgramSource().toString());
        shaderState.apply();

        JOGLShaderObjectsState joglShader = (JOGLShaderObjectsState)shaderState;

        // Need to bind attributes in some cases
        if (m_vertAttributes.contains(GLSLDefaultVariables.BoneIndices) && joglShader.getProgramIdentifier() > 0)
        {
            final GL gl = GLU.getCurrentGL();
            joglShader.setHasAttributes(true);
            gl.glBindAttribLocation(joglShader.getProgramIdentifier(), 1, "boneIndices"); // alias attribute with index one as boneIndices
        }
        // done
        m_bShaderLoaded = true;
    }

    /**
     * Returns the list of shader properties that are modifiable from
     * a higher level. This includes uniforms and vertex attributes
     * @return The array of ShaderProperty objects
     */
    public ShaderProperty[] getProperties()
    {
        Object[] objArray = m_propertyMap.values().toArray();
        ShaderProperty[] result = new ShaderProperty[objArray.length];
        for(int i = 0; i < objArray.length; i++) {
            result[i] = (ShaderProperty)objArray[i];
        }
        return result;
    }

    /**
     * Attempt to populate the specified property with the provided value.
     * @param prop The shader property
     * @return True on success, false otherwise
     * @throws imi.scene.shader.NoSuchPropertyException Thrown if the specified
     * property does not exist for this shader program
     */
    public boolean setProperty(ShaderProperty prop) throws NoSuchPropertyException
    {
        if (m_propertyMap.containsKey(prop.name) == false)
            throw new NoSuchPropertyException(prop.name + " is not valid in this program");
        m_propertyMap.get(prop.name).setValue(prop.getValue());
        
        return true;
    }
    
    /**
     * Utility method to load the shader state
     */
    private void loadAndCompileShader()
    {
        m_WM.addRenderUpdater(this, shaderState);
    }
    
    /**
     * This method scans the collection of effects for their uniforms and exposes
     * them as ShaderProperty objects to facilitate manipulation
     */
    protected void synchronizePropertyObjects()
    {
        // for each effect
        for (GLSLShaderEffect effect : m_effects)
        {
            // for each uniform (if any exist)
            if (effect.getFragmentUniforms() != null)
            {
                for (GLSLShaderUniform uniform : effect.getFragmentUniforms())
                {
                    if (m_propertyMap.containsKey(uniform.getName()) == false) // add it in!
                    {
                        ShaderProperty prop = new ShaderProperty(uniform.getName(), uniform.getDataType(), null);
                        m_propertyMap.put(uniform.getName(), prop);
                    }
                }
            }
            if (effect.getVertexUniforms() != null)
            {
                for (GLSLShaderUniform uniform : effect.getVertexUniforms())
                {
                    if (m_propertyMap.containsKey(uniform.getName()) == false) // Add it in!
                    {
                        ShaderProperty prop = new ShaderProperty(uniform.getName(), uniform.getDataType(), null);
                        m_propertyMap.put(uniform.getName(), prop);
                    }
                }
            }
        }
    }

    /**
     * Clear the property map out. This should be called before a compile any time
     * effects are removed from the program
     */
    public void clearPropertyMap()
    {
        m_propertyMap.clear();
    }
    
    /**
     * Assign the source strings
     * @param vertexSource
     * @param fragmentSource
     */
    protected void setSourceStrings(String vertexSource, String fragmentSource)
    {
        m_VertexProgramSource = new StringBuilder(vertexSource);
        m_FragmentProgramSource = new StringBuilder(fragmentSource);
    }

    /**
     * Build and retrieve the shader program dom representation.
     * @return
     */
    final public xmlShaderProgram generateShaderProgramDOM()
    {
        xmlShaderProgram result = new xmlShaderProgram();

        Constructor defaultCtor = null;
        GLSLShaderProgram vanillaInstance = null;
        // Run the exception gauntlet
        try {
            // Determine if we are a vanilla instance, or if we have been modified
            defaultCtor = this.getClass().getConstructor(WorldManager.class);
            vanillaInstance = (GLSLShaderProgram) defaultCtor.newInstance(m_WM);
        } catch (NoSuchMethodException ex) {
            // This just means that we are not using a dynamic shader
        } catch (SecurityException ex) {
            Logger.getLogger(GLSLShaderProgram.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
        } catch (InstantiationException ex) {
            Logger.getLogger(GLSLShaderProgram.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
        } catch (IllegalAccessException ex) {
            Logger.getLogger(GLSLShaderProgram.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
        } catch (IllegalArgumentException ex) {
            Logger.getLogger(GLSLShaderProgram.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
        } catch (InvocationTargetException ex) {
            Logger.getLogger(GLSLShaderProgram.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
        }

        // TODO : See if there is a less wasteful way to do this
        if (this.containsSameEffectsAs(vanillaInstance))
            result.setDefaultProgramName(this.getClass().getName());
        else
        {
            constructManualShaderDOM(result);
        }
        return result;
    }

    /**
     * This method fills out the provided shader program dom with the
     * appropriate list of constituent effects.
     * @param shaderDOM
     */
    private void constructManualShaderDOM(xmlShaderProgram shaderDOM) {
        // clear out program name portion
        shaderDOM.setDefaultProgramName(null);
        // list each effect
        for (GLSLShaderEffect effect : m_effects)
            shaderDOM.addEffect(effect.getClass().getSimpleName());
    }

    /**
     * Determines if this instance has the same effects as the other. The effect
     * lists much match perfectly.
     * @param other The program to compare against.
     * @return True if the same effects are contained, false otherwise
     */
    public boolean containsSameEffectsAs(GLSLShaderProgram other)
    {
        boolean result = true; // Assume equality until proven otherwise
        if (other != null)
        {
            if (m_effects != null && other.m_effects != null)
            {
                if (m_effects.size() != other.m_effects.size())
                    result = false;
                else
                {
                    // check all of ours against theirs
                    for (GLSLShaderEffect effect : m_effects)
                    {
                        if (other.containsEffect(effect) == false)
                        {
                            result = false;
                            break;
                        }
                    }
                }
            }
            else if (m_effects == null && other.m_effects == null)
                result = true;
            else // inequality
                result = false;
        }
        else
            result = false;
        
        return result;
    }

    public AbstractShaderProgram duplicate()
    {
        GLSLShaderProgram result = new GLSLShaderProgram(this);
        return result;
    }

    //////// SERIALIZATION HELPERS /////////////
    private void writeObject(java.io.ObjectOutputStream out) throws IOException
    {
        out.defaultWriteObject();
    }

    private void readObject(java.io.ObjectInputStream in) throws IOException,
                                                        ClassNotFoundException
    {
        in.defaultReadObject();
    }

}
